from typing import (
    List,
    Tuple,
    Optional,
    Dict,
    Union,
)

from datetime import datetime, timezone, date

import credmark.model

from credmark.model import ModelRunError

from credmark.types.dto import (
    DTO,
    DTOField,
)

from credmark.types import (
    Portfolio,
    Price,
    Address,
    BlockNumber,
    BlockSeries,
    Token,
)

import numpy as np
import pandas as pd


class PriceList(DTO):
    price: Price
    token: Address


class VaRInput(DTO):
    # block_number: int
    portfolio: Portfolio
    window: str
    intervals: List[str] = DTOField(...)
    confidences: List[float] = DTOField(..., gt=0.0, lt=1.0)  # accepts multiple values
    asOf: Optional[List[date]]
    outputPrice: Optional[bool] = DTOField(False)
    debug: Optional[bool] = DTOField(False)

    class Config:
        validate_assignment = True


class VaRPrepare(DTO):
    tokens: List[Token]
    window: str
    interval: str = DTOField(...)
    block_hist: int

    class Config:
        validate_assignment = True


class VaROutput(DTO):
    var: Dict[str, Dict[str, Dict[float, float]]]


CREDMARK_ADDRESS = "0x68CFb82Eacb9f198d508B514d898a403c449533E"


@credmark.model.describe(slug='finance.var-prepare',
                         version='1.0',
                         display_name='Prepare data for Value at Risk',
                         description='Prepare data for Value at Risk',
                         input=VaRPrepare,
                         output=dict)
class ValueAtRiskPrepare(credmark.model.Model):
    def run(self, input: VaRPrepare) -> dict:
        df_ret = pd.DataFrame()
        dict_price = {}
        dict_hist = {}
        dict_ret = {}

        for tk in input.tokens:
            if tk.symbol in df_ret:
                continue

            if not tk.symbol:
                raise ModelRunError(f'Input position is invalid, {input}')

            historical = self.context.run_model(
                'uniswap-v3.get-historical-price',
                input={
                    'token': tk,
                    'window': input.window,
                    'interval': input.interval,
                },
                block_number=input.block_hist)

            for p in historical['series']:
                p['price'] = p['output']['price']
                del p['output']

            df_hist = pd.DataFrame(historical['series']).sort_values(
                ['blockNumber'], ascending=False)

            df_hist.loc[:, 'blockTime'] = df_hist.blockTimestamp.apply(
                lambda x: datetime.fromtimestamp(x, timezone.utc).date())
            df_hist.loc[:, 'sampleTime'] = df_hist.sampleTimestamp.apply(
                lambda x: datetime.fromtimestamp(x, timezone.utc).date())

            ret = df_hist.price[:-1].to_numpy() / df_hist.price[1:].to_numpy()

            df_ret.loc[:, tk.symbol] = ret

            # The last block_number in df may not equal to the input block_number.
            # specify block_number=df.blockNumber.max() with run_model() to get the match price.
            current = self.context.run_model(
                'price', tk, return_type=Price, block_number=input.block_hist)

            dict_price[tk.symbol] = current.price

            dict_hist[input.window] = df_hist
            dict_ret[input.window] = df_ret

        return {'hist': dict_hist,
                'ret': dict_ret,
                'current': dict_price}


@credmark.model.describe(slug='finance.var-demo',
                         version='1.0',
                         display_name='Value at Risk',
                         description='Value at Risk',
                         input=VaRInput,
                         output=VaROutput)
class ValueAtRisk(credmark.model.Model):
    @staticmethod
    def calc_var(ppl, lvl):
        ppl_d = ppl.copy()
        ppl_d.sort()
        len_ppl_d = ppl_d.shape[0]
        pos_f = lvl * (len_ppl_d - 1)
        lower = int(np.floor(pos_f))
        upper = int(np.ceil(pos_f))
        return ppl_d[lower] * (upper - pos_f) + ppl_d[upper] * (pos_f - lower)

    def get_block_number_of_date(self, dt: Union[date, datetime]):
        txn_blocks = self.context.ledger.Block.Columns
        dt = datetime(dt.year, dt.month, dt.day, tzinfo=timezone.utc)
        result = self.context.ledger.get_blocks(
            [txn_blocks.TIMESTAMP, txn_blocks.NUMBER],
            where=f"{txn_blocks.TIMESTAMP} >= {int(dt.timestamp())}",
            order_by=f'{txn_blocks.TIMESTAMP} ASC',
            limit='1')

        rows = result.data
        block_hist = rows[0].get(txn_blocks.NUMBER) if len(rows) else None

        return block_hist

    def get_date_of_block(self, block_hist: int):
        txn_blocks = self.context.ledger.Block.Columns

        result = self.context.ledger.get_blocks(
            [txn_blocks.TIMESTAMP, txn_blocks.NUMBER],
            where=f"{txn_blocks.NUMBER} = {int(block_hist)}",
            order_by=f'{txn_blocks.TIMESTAMP} ASC',
            limit='1')

        rows = result.data
        timestamp = rows[0].get(txn_blocks.TIMESTAMP) if len(rows) else None
        if timestamp:
            dt = [datetime.fromtimestamp(timestamp, timezone.utc).date()]
        else:
            raise ModelRunError(f'Can not get the timestamp for block={block_hist}')

        return dt

    def run(self, input: VaRInput) -> VaROutput:
        """
            Var takes in a portfolio object,
            a list of prices per token into the past,
            a price window,
            and a worst case percentage.

            It calculates the usd value of the portfolio for each of the blockstamps/timestamps.
            It then calculates the change in value over the window period for each timestamp,
            it returns the one that hits the input percentage.
        """

        input_tokens = [p.token for p in input.portfolio.positions]

        if input.asOf:
            min_date = min(input.asOf)
            self.get_block_number_of_date(min_date)
            print('rows', rows, input.asOf, block_hist)
        else:
            block_hist = self.context.block_number
            self.get_date_of_block(block_hist)

            print('rows', rows, input.asOf, block_hist)

        rows = result.data
        block_hist = rows[0].get(txn_blocks.NUMBER) if len(rows) else None

        rows = result.data
        block_hist = rows[0].get(txn_blocks.NUMBER) if len(rows) else None
        return block_hist

        self.context.run_model('finance.var-prepare',
                               input={'tokens': input_tokens,
                                      'window':
                                      'interval':
                                      'block_hist':}
                               )
        # check windows
        _ = self.context.historical.parse_timerangestr(input.window)

        # check intervals
        parsed_intervals = [
            self.context.historical.parse_timerangestr(ii) for ii in input.intervals]
        interval_keys, interval_nums = zip(*parsed_intervals)
        unique_interval_keys = list(set(interval_keys))
        if unique_interval_keys.__len__() != 1:
            raise ModelRunError(
                f'There is more than one type of interval in input intervals={input.intervals}')

        minimal_interval = f'1 {unique_interval_keys[0]}'

        var = {}

        var[window] = {}
        for ivl, ivl_str in zip(interval_nums, input.intervals):
            var[window][ivl_str] = {}
            df_ret_n = df_ret.copy().rolling(ivl).agg(lambda x: x.prod()) - 1
            # assert np.all(df_ret.copy().rolling(1).agg(lambda x : x.prod()) == df_ret.copy())
            for conf in input.confidences:
                df_value = pd.DataFrame()
                for pos in input.portfolio.positions:
                    ret = df_ret_n[pos.token.symbol]
                    current_value = pos.amount * dict_price[pos.token.symbol]
                    value_changes = ret * current_value
                    if pos.token.symbol not in df_value:
                        df_value.loc[:, pos.token.symbol] = value_changes
                    else:
                        df_value.loc[:, pos.token.symbol] += value_changes
                ppl = df_value.sum(axis=1).to_numpy()
                var[window][ivl_str][conf] = self.calc_var(ppl, conf)

        result = VaROutput(asOf=input.asOf.strftime('%Y-%m-%d'), var=var)

        return result
